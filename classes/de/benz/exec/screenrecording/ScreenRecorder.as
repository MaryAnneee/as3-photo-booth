package de.benz.exec.screenrecording {    import flash.desktop.NativeProcess;    import flash.desktop.NativeProcessStartupInfo;    import flash.errors.IllegalOperationError;    import flash.events.Event;    import flash.events.EventDispatcher;    import flash.events.NativeProcessExitEvent;    import flash.events.ProgressEvent;    import flash.filesystem.File;    import flash.utils.setTimeout;        public class ScreenRecorder extends EventDispatcher {		private var vlcFile:File;		public var targetFile:File;		private var p:NativeProcess = new NativeProcess();				[Bindable]		public var isRecording:Boolean = false;		        public function ScreenRecorder(vclFile:File) {			this.vlcFile = vclFile;        }		        public function startRecording(targetFile:File):void {			this.targetFile = targetFile;            isRecording = true;            			if(targetFile.exists){				targetFile.deleteFile();			}                        var startupInfo:NativeProcessStartupInfo = new NativeProcessStartupInfo();            startupInfo.executable = vlcFile;                        var processArgs:Vector.<String> = new Vector.<String>();            processArgs.push("-I");            processArgs.push("rc"); //Remote control            processArgs.push("--rc-fake-tty"); //Use terminal as output            processArgs.push("screen://");            processArgs.push(":screen-fps=15");            processArgs.push(":screen-caching=100");          	processArgs.push(":sout=#transcode{venc=x264{bframes=0,nocabac,ref=1,nf,level=13,crf=24,partitions=none},vcodec=h264,fps=15,vb=3000,width=800,height=600,acodec=none}:duplicate{dst=std{mux=mp4,access=file,dst='"+targetFile.nativePath+"'}}");	      	//processArgs.push(":sout=#transcode{vcodec=mp2v,fps=30,vb=1024,width=320,acodec=mp2a,ab=128,scale=1,channels=2,deinterlace,audio-sync}:duplicate{dst=standard{access=file,mux=ps,dst=std{mux=mp4,access=file,dst='"+targetFile.nativePath+"'},dst=display{noaudio}}} --extraintf=logger -vvv");		    //processArgs.push(":sout=#transcode{venc=x264{bframes=0,nocabac,ref=1,nf,level=13,crf=24,partitions=none},vcodec=h264,fps=15,vb=3000,width=800,height=600,acodec=mp2a,ab=128,scale=1,channels=2,audio-sync}:duplicate{dst=std{mux=mp4,access=file,dst='"+targetFile.nativePath+"'}}");						startupInfo.arguments = processArgs;						p = new NativeProcess();			p.addEventListener(ProgressEvent.STANDARD_OUTPUT_DATA, onOutputData);			p.addEventListener(ProgressEvent.STANDARD_ERROR_DATA, onErrorData);			p.addEventListener(NativeProcessExitEvent.EXIT, onExit);                        try {                p.start(startupInfo);            } catch (e:IllegalOperationError) {				trace("Illegal Operation: " + e.toString());            } catch (ae:ArgumentError) {				trace("Argument Error: " + ae.toString());            } catch (e:Error) {				trace("Error: " + e.toString());            }        }                public function stopRecording():void{        	p.standardInput.writeUTFBytes("stop" + "\n");        	setTimeout(kill,4000);        	        }                 private function kill():void{         	p.standardInput.writeUTFBytes("quit" + "\n");			isRecording = false;			dispatchEvent(new Event(Event.COMPLETE));         }		                 public function onExit(e:NativeProcessExitEvent):void {			trace("Native Process Exit code: "+e.exitCode);        }                private var recordStartTime:int;        private function onOutputData(evt:ProgressEvent):void{        	var outputData:String = p.standardOutput.readUTFBytes(p.standardOutput.bytesAvailable);        	//trace(outputData);		}					private function onErrorData(evt: ProgressEvent):void{			var errorData:String = p.standardError.readUTFBytes(p.standardError.bytesAvailable);			//trace(errorData);		}    }}